from tkinter import *
from matplotlib.figure import Figure
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import serial, threading, time, math
import sys
import re
import matplotlib
import datetime
from tkinter import filedialog

from mpl_toolkits.mplot3d import Axes3D  # Necesario para la proyección 3D
import numpy as np  # Necesario para generar la esfera de la Tierra

# MAPA (CARTOPY)
try:
    import cartopy.crs as ccrs
    import cartopy.feature as cfeature
    CARTOPY_AVAILABLE = True
except ImportError:
    CARTOPY_AVAILABLE = False
    print("¡ADVERTENCIA! La librería 'cartopy' no está instalada. La vista de Mapa 2D no funcionará.")
# ------------------------------

LOG_FILE = "eventos.log"

def registrar_evento(codigo, tipo, mensaje):
    fecha = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    linea = f"{fecha}\t{codigo}\t{tipo}\t{mensaje}\n"
    with open(LOG_FILE, "a") as f:
        f.write(linea)
    print("Evento registrado:", linea.strip())

eventos = {
    # COMANDOS
    201: ("COMANDO", "Parar envío de temperatura (S1)"),
    202: ("COMANDO", "Parar envío de humedad (S2)"),
    203: ("COMANDO", "Parar envío de distancia (S3)"),
    204: ("COMANDO", "Reanudar temperatura (R1)"),
    205: ("COMANDO", "Reanudar humedad (R2)"),
    206: ("COMANDO", "Reanudar distancia (R3)"),
    207: ("COMANDO", "Movimiento manual servo (RM:x)"),
    208: ("COMANDO", "Parar todos los sensores (S)"),
    209: ("COMANDO", "Reanudar todos los sensores (R)"),
    210: ("COMANDO", "Iniciar temperatura normal (R1)"),
    211: ("COMANDO", "Parar temperatura desde interfaz (S1)"),
    # ALARMAS
    301: ("ALARMA", "Error de lectura de temperatura (1!)"),
    302: ("ALARMA", "Error de lectura de humedad (2!)"),
    303: ("ALARMA", "Error combinado TEMP+HUM (1!2)"),
    304: ("ALARMA", "Mensaje corrupto recibido (trama LoRa corrupta)"),
    305: ("ALARMA", "Distancia fuera de rango"),
    306: ("ALARMA", "Eco no recibido (No Echo)"),
    # USUARIO
    401: ("USUARIO", "Observación del usuario (texto libre)"),
    402: ("USUARIO", "Nota importante marcada por el usuario"),
    403: ("USUARIO", "Usuario reporta posible fallo físico"),
    404: ("USUARIO", "Usuario reinicia la interfaz"),
    405: ("USUARIO", "Usuario reinicia el satélite"),
    406: ("USUARIO", "Usuario pide que se calcule la media en el arduino")
}

def registrar_evento_por_codigo(codigo):
    if codigo in eventos:
        tipo, mensaje = eventos[codigo]
        registrar_evento(codigo, tipo, mensaje)
    else:
        print("Código de evento no definido:", codigo)

# IMPORTANT: set backend before importing pyplot
matplotlib.use('TkAgg')
import matplotlib.pyplot as plt

def abrir_fichero_comandos():
    ruta = filedialog.askopenfilename(
        title="Abrir fichero de eventos",
        filetypes=(("Fichero de eventos","*.log"), ("Archivos de texto","*.txt"), ("Todos los archivos","*.*"))
    )
    if not ruta: return
    with open(ruta, "r", encoding="utf-8", errors="ignore") as f:
        contenido = f.read()
    win = Toplevel(window)
    win.title(f"Contenido de {ruta}")
    win.geometry("900x500")
    text = Text(win, wrap="none")
    text.insert("1.0", contenido)
    text.config(state="disabled") 
    text.pack(fill="both", expand=True)
    scrollbar_y = Scrollbar(win, orient="vertical", command=text.yview)
    scrollbar_y.pack(side="right", fill="y")
    text.config(yscrollcommand=scrollbar_y.set)

# ---------------- SERIAL ----------------
device = 'COM7' 
try:
    ser = serial.Serial(device, 9600, timeout=1)
    print("Serial abierto en", device)
except Exception as e:
    print("No se pudo abrir serial:", e)
    ser = None

# ---------------- VARIABLES ----------------
data_lock = threading.Lock()


temperaturas = []
humedades = []
distancias = []
angulos = []
eje_x = []
medias_arduino = []

# Configuracion Graficas
MAX_POINTS_RADAR = 5
MAX_POINTS_ORBIT = 50 
MAX_POINTS_MAPA = 300 # Historial para el mapa 2D

# Flags de graficas
grafica_temp = False
grafica_hum = False
grafica_dist = False
radarEncendido = False
orbitaEncendida = False
mapaEncendido = False 

solicitud_media_popup = False

# Matplotlib para Tkinter
canvas_temp = None
media_arduino = None
fig_temp = None
ax_temp = None

canvas_radar = None
fig_radar = None
ax_radar = None

canvas_orbita = None
fig_orbita = None
ax_orbita = None

# Variables Mapa 2D
canvas_mapa = None
fig_mapa = None
ax_mapa = None
traj_line_map = None
current_pos_map = None

# Variables para la órbita
R_EARTH = 6371000 
x_vals = []
y_vals = []
z_vals = []

# ---------------- LECTOR SERIAL ----------------

def lector_serial():
    global media_arduino
    if ser is None: 
        return

    while True:
        try:
            linea = ser.readline().decode('utf-8', errors='ignore').strip()
            if not linea:
                continue

        

            with data_lock:
                # -------- SENSORES --------
                if '1:' in linea:
                    try: temperaturas.append(float(linea.split('1:')[1].split()[0]))
                    except: pass
                if ' 2:' in linea:
                    try: humedades.append(float(linea.split(' 2:')[1].split()[0]))
                    except: pass
                if ' 3:' in linea:
                    try: distancias.append(float(linea.split(' 3:')[1].split()[0]))
                    except: pass
                if ' 4:' in linea:
                    try: angulos.append(float(linea.split(' 4:')[1].split()[0]))
                    except: pass

                # -------- POSICIÓN --------
                if linea.startswith("POS"):
                    valores = re.findall(r"[-+]?\d*\.\d+|[-+]?\d+", linea)
                    if len(valores) >= 3:
                        x_vals.append(float(valores[0]))
                        y_vals.append(float(valores[1]))
                        z_vals.append(float(valores[2]))
                        if len(x_vals) > 500:
                            x_vals.pop(0); y_vals.pop(0); z_vals.pop(0)

                # -------- MEDIA --------
                if linea.startswith("5:"):
                    try:
                        valor = float(linea.split(":")[1])
                        media_arduino = valor
                        medias_arduino.append(valor)
                        
                        
                        window.after(0, lambda v=valor: media_label.config(text=f"Media: {v:.2f} °C"))
                        
                        # LÓGICA DEL POPUP
                        global solicitud_media_popup
                        if solicitud_media_popup:
                            
                            # Usamos window.after para pedirle a la ventana principal que abra el Popup
                            window.after(0, lambda v=valor: mostrar_media_popup(v))
                            
                            solicitud_media_popup = False # Bajamos la bandera inmediatamente
                            
                    except Exception as e:
                        print("Error procesando media:", e)

        except Exception as e:
            print("Error lector_serial:", e)

        time.sleep(0.01)


# ---------------- GRAFICAS TEMP/HUM ----------------
def init_grafica_temp():
    global canvas_temp, fig_temp, ax_temp
    if canvas_temp is None:
        fig_temp = Figure(figsize=(8,4), dpi=100)
        ax_temp = fig_temp.add_subplot(111)
        ax_temp.set_facecolor('#FFFFFF')
        canvas_temp = FigureCanvasTkAgg(fig_temp, master=plot_frame)
        canvas_temp.get_tk_widget().pack(fill='both', expand=True)

linea_temp = None
linea_media = None
linea_hum = None

def plot_temp():
    global grafica_temp, linea_temp, linea_media
    MAX_POINTS_TEMP = 50
    init_grafica_temp()
    
    with data_lock:
        ys = temperaturas[-MAX_POINTS_TEMP:]
        xs = list(range(len(ys)))

    if linea_temp is None:
        linea_temp, = ax_temp.plot(xs, ys, color='blue', label='TEMPERATURA')
        linea_media, = ax_temp.plot(xs, ys, color='green', label='MEDIA 10')
        ax_temp.set_xlabel('Últimas lecturas')
        ax_temp.set_ylabel('Temperatura (°C)')
        ax_temp.legend()
        ax_temp.set_xlim(0, MAX_POINTS_TEMP)
        if ys: ax_temp.set_ylim(0, max(ys + [30]))
    
    while grafica_temp:
        with data_lock:
            ys_all = list(temperaturas)
        if not ys_all:
            time.sleep(0.1)
            continue
        ys = ys_all[-MAX_POINTS_TEMP:]
        xs = list(range(len(ys)))
        linea_temp.set_data(xs, ys)
        if len(ys) >= 10:
            media = [sum(ys[-10:])/10.0]*len(ys)
            linea_media.set_data(xs, media)
        if ys:
            ymin = min(ys) - 1
            ymax = max(ys) + 1
            ax_temp.set_ylim(ymin, ymax)
        canvas_temp.draw_idle()
        time.sleep(0.1)

def plot_hum():
    global grafica_hum, linea_hum
    MAX_POINTS_TEMP = 50
    init_grafica_temp()
    if linea_hum is None:
        with data_lock:
            ys = humedades[-MAX_POINTS_TEMP:]
            xs = list(range(len(ys)))
        linea_hum, = ax_temp.plot(xs, ys, color='red', label='HUMEDAD')
        ax_temp.legend()
    while grafica_hum:
        with data_lock:
            ys_all = list(humedades)
        if not ys_all:
            time.sleep(0.1)
            continue
        ys = ys_all[-MAX_POINTS_TEMP:]
        xs = list(range(len(ys)))
        linea_hum.set_data(xs, ys)
        if ys:
            ymin = min(ys) - 1
            ymax = max(ys) + 1
            ax_temp.set_ylim(ymin, ymax)
        canvas_temp.draw_idle()
        time.sleep(0.25)

# ---------------- RADAR ----------------
def init_radar():
    global canvas_radar, fig_radar, ax_radar, radarEncendido
    if radarEncendido: return
    radarEncendido = True
    fig_radar = Figure(figsize=(6,4), dpi=100)
    ax_radar = fig_radar.add_subplot(111, polar=True)
    ax_radar.set_theta_zero_location("E")
    ax_radar.set_theta_direction(-1)
    ax_radar.set_title("Radar Ultrasonico")
    canvas_radar = FigureCanvasTkAgg(fig_radar, master=radar_frame)
    canvas_radar.get_tk_widget().pack(fill='both', expand=True)
    threading.Thread(target=actualizar_radar, daemon=True).start()

def actualizar_radar():
    global radarEncendido
    while radarEncendido:
        try:
            with data_lock:
                angs_all = list(angulos)
                dists_all = list(distancias)
            if not angs_all or not dists_all or len(angs_all) != len(dists_all):
                time.sleep(0.1)
                continue
            angs = angs_all[-MAX_POINTS_RADAR:]
            dists = dists_all[-MAX_POINTS_RADAR:]
            ax_radar.clear()
            ax_radar.set_theta_zero_location("E")
            ax_radar.set_theta_direction(-1)
            ax_radar.set_ylim(0, max(dists)*1.1 if dists else 1)
            thetas = [math.radians(a) for a in angs]
            ax_radar.plot(thetas, dists, marker='o', linestyle='-', linewidth=2)
            if thetas: ax_radar.plot([thetas[-1]], [dists[-1]], marker='o', markersize=8)
            canvas_radar.draw_idle()
        except: pass
        time.sleep(0.2)

def radar_manual():
    win = Toplevel(window)
    win.title("Control Motor")
    Label(win, text="Mover Motor", font=("Arial",14)).pack(pady=10)
    slider = Scale(win, from_=-90, to=90, orient="horizontal", length=300, resolution=1, command=enviar_direccion)
    slider.set(0)
    slider.pack(pady=20)

def enviar_direccion(val):
    val = float(val)
    angulo = int(90 + val)
    angulo = max(0, min(180, angulo))
    if ser is not None:
        ser.write(f"RM:{angulo}\n".encode())
        print("Enviado:", angulo)


# ---------------- ORBITA 3D ----------------
def init_orbita():
    global canvas_orbita, fig_orbita, ax_orbita, orbitaEncendida
    if orbitaEncendida: return
    orbitaEncendida = True

    fig_orbita = Figure(figsize=(6,6), dpi=100)
    ax_orbita = fig_orbita.add_subplot(111, projection='3d')
    ax_orbita.set_xlabel('X (m)'); ax_orbita.set_ylabel('Y (m)'); ax_orbita.set_zlabel('Z (m)')
    ax_orbita.set_title('Órbita Satelital 3D')
    
    u = np.linspace(0, 2 * np.pi, 30); v = np.linspace(0, np.pi, 30)
    x_earth = R_EARTH * np.outer(np.cos(u), np.sin(v))
    y_earth = R_EARTH * np.outer(np.sin(u), np.sin(v))
    z_earth = R_EARTH * np.outer(np.ones(np.size(u)), np.cos(v))
    ax_orbita.plot_wireframe(x_earth, y_earth, z_earth, color='orange', alpha=0.3, rstride=2, cstride=2)

    theta = np.linspace(0, 2*np.pi, 100)
    ax_orbita.plot(R_EARTH*np.cos(theta), R_EARTH*np.sin(theta), np.zeros_like(theta), color='green', linestyle='--', linewidth=1.5, label='Ecuador')
    
    limit = R_EARTH * 1.5
    ax_orbita.set_xlim(-limit, limit); ax_orbita.set_ylim(-limit, limit); ax_orbita.set_zlim(-limit, limit)
    try: ax_orbita.set_box_aspect([1,1,1])
    except: pass 

    orbit_plot, = ax_orbita.plot([], [], [], 'b-', linewidth=2, label='Órbita')
    last_point_plot = ax_orbita.scatter([], [], [], color='red', s=50, label='Posición')
    ax_orbita.legend()
    ax_orbita.view_init(elev=30, azim=45)

    # MASTER ES ORBIT_FRAME
    canvas_orbita = FigureCanvasTkAgg(fig_orbita, master=orbit_frame)
    canvas_orbita.get_tk_widget().pack(fill='both', expand=True)

    def actualizar_orbita():
        nonlocal orbit_plot, last_point_plot
        while orbitaEncendida:
            try:
                with data_lock:
                    xs_all = list(x_vals); ys_all = list(y_vals); zs_all = list(z_vals)
                if not xs_all:
                    time.sleep(0.15); continue
                
                xs = xs_all[-MAX_POINTS_ORBIT:]
                ys = ys_all[-MAX_POINTS_ORBIT:]
                zs = zs_all[-MAX_POINTS_ORBIT:]
                orbit_plot.set_data(xs, ys); orbit_plot.set_3d_properties(zs)
                last_point_plot._offsets3d = ([xs[-1]], [ys[-1]], [zs[-1]])

                max_val = R_EARTH
                if xs: max_val = max(max_val, np.max(np.abs(xs)))
                current_limit = ax_orbita.get_xlim()[1]
                if max_val * 1.1 > current_limit:
                      new_limit = max_val * 1.2
                      ax_orbita.set_xlim(-new_limit, new_limit)
                      ax_orbita.set_ylim(-new_limit, new_limit)
                      ax_orbita.set_zlim(-new_limit, new_limit)
                canvas_orbita.draw_idle()
            except: pass
            time.sleep(0.2)
    threading.Thread(target=actualizar_orbita, daemon=True).start()


# MAPA 2D (GROUND TRACK) 
def xyz_to_latlon(x, y, z):
    r = math.sqrt(x*x + y*y + z*z)
    if r == 0: return 0, 0
    lat = math.degrees(math.asin(z / r))
    lon = math.degrees(math.atan2(y, x))
    return lat, lon

def init_mapa():
    global canvas_mapa, fig_mapa, ax_mapa, mapaEncendido, traj_line_map, current_pos_map
    if not CARTOPY_AVAILABLE: return
    if mapaEncendido: return
    mapaEncendido = True

    fig_mapa = Figure(figsize=(6, 6), dpi=100)
    projection = ccrs.PlateCarree()
    ax_mapa = fig_mapa.add_subplot(111, projection=projection)
    
    ax_mapa.add_feature(cfeature.LAND, facecolor='orange')
    ax_mapa.add_feature(cfeature.OCEAN, facecolor='cyan')
    ax_mapa.add_feature(cfeature.COASTLINE, linewidth=0.5)
    ax_mapa.add_feature(cfeature.BORDERS, linestyle=':', linewidth=0.5)
    ax_mapa.set_global()
    ax_mapa.set_title("Trayectoria del Satélite (Ground Track)")

    traj_line_map, = ax_mapa.plot([], [], color='blue', linewidth=2, transform=ccrs.PlateCarree())
    current_pos_map = ax_mapa.scatter([], [], color='red', s=50, zorder=10, transform=ccrs.PlateCarree())

    # MASTER ES ORBIT_FRAME
    canvas_mapa = FigureCanvasTkAgg(fig_mapa, master=orbit_frame)
    canvas_mapa.get_tk_widget().pack(fill='both', expand=True)

    def actualizar_mapa_thread():
        while mapaEncendido:
            try:
                with data_lock:
                    xs = list(x_vals); ys = list(y_vals); zs = list(z_vals)
                if not xs:
                    time.sleep(0.2); continue
                
                xs_map = xs[-MAX_POINTS_MAPA:]
                ys_map = ys[-MAX_POINTS_MAPA:]
                zs_map = zs[-MAX_POINTS_MAPA:]

                lats = []; lons = []
                for i in range(len(xs_map)):
                    lat, lon = xyz_to_latlon(xs_map[i], ys_map[i], zs_map[i])
                    lats.append(lat); lons.append(lon)
                
                traj_line_map.set_data(lons, lats)
                current_pos_map.set_offsets([[lons[-1], lats[-1]]])
                canvas_mapa.draw_idle()
            except: pass
            time.sleep(0.5)
    threading.Thread(target=actualizar_mapa_thread, daemon=True).start()

# FUNCIÓN PARA ALARMA 
def SET_ALARMAClick():
    val = entrada_limite.get()
    try:
        float(val) # Validamos que sea un número
        if ser: 
            ser.write(f"MAXT:{val}\n".encode()) # Enviamos formato MAXT:xx
            print(f"Comando enviado: MAXT:{val}")
            registrar_evento(401, "USUARIO", f"Límite alarma cambiado a {val}")
    except ValueError:
        print("Error: Introduce un número válido para la alarma")

def mostrar_media_popup(valor):
    win = Toplevel(window)
    win.title("Media de Temperatura")
    win.geometry("250x120")
    win.resizable(False, False)

    Label(win, text="Media Temperatura (ºC)",
          font=("Arial", 12, "bold")).pack(pady=10)

    Label(win, text=f"{valor:.2f} ºC",
          font=("Arial", 14),
          fg="blue").pack(pady=5)

    Button(win, text="Cerrar", command=win.destroy).pack(pady=5)

# ---------------- BOTONES Y GUI ----------------
def TEMPClick():
    global grafica_temp
    grafica_temp = True
    init_grafica_temp()
    threading.Thread(target=plot_temp, daemon=True).start()
    if ser: ser.write(b"R1\n")
    registrar_evento_por_codigo(204)

def MEDIAClick():
    global solicitud_media_popup
    solicitud_media_popup = True 
    
    if ser: ser.write(b"M\n")
    registrar_evento_por_codigo(406)

def HUMClick():
    global grafica_hum
    grafica_hum = True
    init_grafica_temp()
    threading.Thread(target=plot_hum, daemon=True).start()
    if ser: ser.write(b"R2\n")
    registrar_evento_por_codigo(205)

def STOPTClick():
    global grafica_temp
    grafica_temp = False
    if ser: ser.write(b"S1\n")
    registrar_evento_por_codigo(201)

def STOPHClick():
    global grafica_hum
    grafica_hum = False
    if ser: ser.write(b"S2\n")
    registrar_evento_por_codigo(202)

def RADARClick():
    init_radar()
    if ser: ser.write(b"R3\n")
    registrar_evento_por_codigo(207)

def RADARMClick():
    radar_manual()
    init_radar()

def ORBITClick():
    global mapaEncendido, canvas_mapa, orbitaEncendida
    # Apagar mapa si existe
    if mapaEncendido:
        mapaEncendido = False
        if canvas_mapa:
            canvas_mapa.get_tk_widget().destroy()
            canvas_mapa = None
    # Encender orbita
    if not orbitaEncendida:
        init_orbita()
        registrar_evento_por_codigo(210)

def MAPAClick():
    global orbitaEncendida, canvas_orbita, mapaEncendido
    # Apagar orbita si existe
    if orbitaEncendida:
        orbitaEncendida = False
        if canvas_orbita:
            canvas_orbita.get_tk_widget().destroy()
            canvas_orbita = None
    # Encender mapa
    if CARTOPY_AVAILABLE:
        if not mapaEncendido:
            init_mapa()
    else:
        print("Cartopy no instalado.")

# ---------------- INTERFAZ PRINCIPAL ----------------
window = Tk()
window.geometry("1800x800") # Altura reducida
window.title("INTERFAZ VERSION 4") 
window.rowconfigure([0,1,2,3,4,5], weight=1)
window.columnconfigure([0,1,2,3,4,5,6], weight=1)

Label(window, text="VERSION 4", font=("Times New Roman", 20, "bold")).grid(row=0,column=0,columnspan=7,sticky=N+S+E+W)

botones = {'width':12,'height':2,'font':("Arial",11,"bold"),'relief':'raised','bd':3}
Button(window,text="TEMP", command=TEMPClick, bg='blue',fg='white',**botones).grid(row=2,column=0,sticky=N+S+E+W)
Button(window,text="STOPTEMP", command=STOPTClick, bg='blue',fg='white',**botones).grid(row=5,column=0,sticky=N+S+E+W)
Button(window,text="HUM", command=HUMClick, bg='red',fg='white',**botones).grid(row=2,column=1,sticky=N+S+E+W)
Button(window,text="STOPHUM", command=STOPHClick, bg='red',fg='white',**botones).grid(row=5,column=1,sticky=N+S+E+W)
media_label = Label(window, text="Media: --", font=("Arial",12), bg='white', relief='sunken')
media_label.grid(row=5, column=2, sticky=N+S+E+W, padx=5, pady=5)

Button(window,text="RADAR", command=RADARClick, bg='green',fg='white',**botones).grid(row=2,column=3,sticky=N+S+E+W)
Button(window,text="RADAR MANUAL", command=RADARMClick, bg='green',fg='white',**botones).grid(row=2,column=4,sticky=N+S+E+W)

# Botones de Orbita y Mapa juntos
Button(window,text="ORBITA 3D", command=ORBITClick, bg='orange',fg='white',**botones).grid(row=2,column=5,sticky=N+S+E+W)
Button(window,text="MAPA 2D", command=MAPAClick, bg='cyan',fg='black',**botones).grid(row=2,column=6,sticky=N+S+E+W)

Button(window, text="MEDIA ARDUINO", command=MEDIAClick, bg='purple', fg='white', **botones).grid(row=3, column=0, sticky=N+S+E+W)
Button(window, text="ABRIR COMANDOS", command=abrir_fichero_comandos, bg='gray', fg='white', **botones).grid(row=3, column=1, sticky=N+S+E+W)

plot_frame = Frame(window, bd=2, relief='groove')
plot_frame.grid(row=4,column=0,columnspan=3,sticky=N+S+E+W,padx=5,pady=5)

radar_frame = Frame(window, bd=2, relief='groove')
radar_frame.grid(row=4,column=3,columnspan=2,sticky=N+S+E+W,padx=5,pady=5)

# Orbit frame ahora ocupa 2 columnas para alinearse con los botones de Orbita y Mapa
orbit_frame = Frame(window, bd=2, relief='groove')
orbit_frame.grid(row=4,column=5,columnspan=2,sticky=N+S+E+W,padx=5,pady=5)

# ... (Debajo del botón ABRIR COMANDOS) ...

# PANEL ALARMA 
frame_alarma = Frame(window, bd=2, relief='groove', bg="#eeeeee")
frame_alarma.grid(row=3, column=2, columnspan=2, sticky="nsew", padx=5, pady=2)

Label(frame_alarma, text="Límite Temp (ºC):", bg="#eeeeee", font=("Arial", 10, "bold")).pack(side=LEFT, padx=5)

entrada_limite = Entry(frame_alarma, width=5, font=("Arial", 11))
entrada_limite.pack(side=LEFT, padx=5)
entrada_limite.insert(0, "30") # Valor inicial

Button(frame_alarma, text="FIJAR", command=SET_ALARMAClick, bg='red', fg='white', font=("Arial", 9, "bold")).pack(side=LEFT, padx=5)
# ---------------- PANEL COMANDOS DE USUARIO ----------------
frame_comando = Frame(window, bd=2, relief='groove', bg="#dddddd")
frame_comando.grid(row=3, column=4, columnspan=3,
                   sticky=N+S+E+W, padx=5, pady=2)

Label(frame_comando, text="Escribir comando/nota:",
      bg="#dddddd", font=("Arial", 10, "bold")).pack(side=LEFT, padx=5)

entrada_comando = Entry(frame_comando, width=30, font=("Arial", 11))
entrada_comando.pack(side=LEFT, padx=5)

def enviar_comando_usuario():
    texto = entrada_comando.get().strip()
    if texto:
        registrar_evento(401, "USUARIO", texto)
        entrada_comando.delete(0, END)
        print("Comando guardado:", texto)

entrada_comando.bind("<Return>", lambda event: enviar_comando_usuario())

Button(frame_comando, text="GUARDAR",
       command=enviar_comando_usuario,
       bg='purple', fg='white',
       font=("Arial", 9, "bold")).pack(side=LEFT, padx=5)





# ---------------- INICIAR HILO SERIAL ----------------
if ser is not None:
    threading.Thread(target=lector_serial, daemon=True).start()
else:
    print("Puerto serial no abierto. No se recibirán datos.")

window.mainloop()
